# Please make a copy of this file and call it config.yaml. Make sure not to share it on GitHub, as you will need to
# add sensitive information, e.g. API token.
# Use this newly created copy to adjust all configurations.
APItoken: # your token here
    IBMQ_API_token: ""
    dWave_API_token: ""

QaoaBackend:
    shots: 20000
        # (int) the number of shots
        # max 20,000
    simulate: True
        # (boolean) use a simulator or a QPU
        # if True: use simulator;
        # if False: use real IBMQ QPU (IBMQ API token required)
    noise: True
        # (boolean) simulate with or without noise (only used, when simulate is True)
        # if True: use simulator with noise model (IBMQ API token required);
        # if False: use simulator without noise model
    simulator: "aer_simulator"
        # (string) the qiskit simulator to be used (only used, when simulate is True)
        # choose between "qasm_simulator", "aer_simulator", "statevector_simulator" and "aer_simulator_statevector"
    initial_guess: [ 2.93275, 1.58887 ]
        # (list of float or "rand") the initial guess for the classical optimizer
        # has to be an even number of parameters starting with beta, then gamma, then beta again and so on...;
        # use "rand" if a random initial guess should be used for this parameter. For beta between 0 and 2Pi and for
        # gamma between 0 and Pi
    max_iter: 100
        # (int) maximum number iterations of the classical optimizer
    repetitions: 100
        # (int) number of experiment repetitions
    classical_optimizer: "COBYLA"
        # (string) the classical optimizer to be used
        # choose between "SPSA", "COBYLA" and "ADAM"
    qcGeneration: "IterationMatrix"
        # (string) the method for the generation of the quantum circuit
        # choose between "Ising", "Iteration" and "IterationMatrix"

IsingInterface:
    kirchhoffFactor: 1.0
        # (float)
    monetaryCostFactor: 1.0
        # (float)
    minUpDownFactor: 1.0
        # (float)
    offsetEstimationFactor: 1.0
        # (float)
    estimatedCostFactor: 1.0
        # (float)
    offsetBuildFactor: 1.0
        # (float)
    problemFormulation: "binarysplitNoMarginalCost"
        # (string) the method used to generate the Ising problem
        # choose between "binarysplitNoMarginalCost", "fullsplitGlobalCostSquare", "fullsplitMarginalAsPenalty",
        # "fullsplitNoMarginalCost", "fullsplitLocalMarginalEstimationDistance" and "fullsplitDirectInefficiencyPenalty"

SQABackend:
    seed: 10
        # (int)
    transverseFieldSchedule: ""
        # (string)
    temperatureSchedule: ""
        # (string)
    trotterSlices: 10
        # (int)
    optimizationCycles: 2
        # (int)

DWaveBackend:
    annealing_time: 1
        # (int)
    num_reads1: 1
        # (int)
    chain_strength1: 1
        # (int)
    programming_thermalization: 1
        # (int)
    readout_thermalization: 1
        # (int)
    sampleCutSize: 1
        # (int)
    threshold: 1.0
        # (float)
    strategy: "LowestEnergy"
        # (string)
        # choose between "LowestEnergy", "MajorityVote", "PercentageVote" and "ClosestSample"
    postprocess: "flow"
        # (string)
    
PypsaBackend:
    solver_name: "glpk"
        # (string)


    